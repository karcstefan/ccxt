<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import

class litebit extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'id' => 'litebit',
            'name' => 'Litbit.nl',
            'countries' => ['NL'],
            'has' => array(
                'fetchMarkets' => true,
                'fetchCurrencies' => true,
                'fetchTradingLimits' => false,
                'fetchTradingFees' => false,
                'fetchFundingLimits' => false,
                'fetchTicker' => true,
                'fetchOrderBook' => true,
                'fetchTrades' => false,
                'fetchOHLCV' => false,
                'fetchBalance' => true,
                'cancelOrder' => true,
                'createOrder' => true,
                'editOrder' => false,
                'fetchOrder' => true,
                'fetchOrders' => true,
                'fetchOpenOrders' => true,
                'fetchMyTrades' => true,
                'fetchDepositAddress' => false,
                'fetchDeposits' => false,
                'fetchWithdrawals' => false,
                'fetchTransactions' => false,
                'fetchLedger' => false,
                'withdraw' => false,
                'transfer' => false,
            ),
            'version' => 'v1',
            'urls' => array(
                'logo' => '',
                'api' => 'https://localhost/api',
                'www' => 'https://localhost/',
            ),
            'api' => array(
                'public' => array(
                    'get' => array(
                        'trade-market',
                        'trade-market/{code}/book',
                        'trade-market/{code}/history',
                        'currency',
                    ),
                ),
                'private' => array(
                    'get' => array(
                        'balance',
                        'trade-order',
                        'trade-order/{uuid}',
                    ),
                    'post' => array(
                        'trade-order',
                    ),
                    'delete' => array(
                        'trade-order/{uuid}',
                    ),
                ),
            ),
        ));
    }

    public function fetch_markets($params = array ()) {
        $markets = yield $this->publicGetTradeMarket ($params);
        $results = array();
        for ($i = 0; $i < count($markets->data); $i++) {
            $marketData = $markets->data[$i];
            $results[] = array(
                'id' => $marketData->code,
                'symbol' => $marketData->code,
                'active' => $marketData->is_active,
                'base' => $marketData->base_currency.data.code,
                'baseId' => strtolower($marketData->base_currency.data.code),
                'quote' => $marketData->quote_currency.data.code,
                'quoteId' => strtolower($marketData->quote_currency.data.code),
                'precision' => array(
                    'price' => $marketData->decimals,
                    'cost' => $marketData->decimals,
                    'amount' => $marketData->decimals,
                ),
                // TODO => Missing limits/fees
                'info' => $marketData,
            );
        }
        return $results;
    }

    public function fetch_currencies($params = array ()) {
        $currencies = yield $this->publicGetCurrency ($params);
        $results = array();
        for ($i = 0; $i < count($currencies->data); $i++) {
            $currencyData = $currencies->data[$i];
            $results[] = array(
                'id' => strtolower($currencyData->code),
                'code' => $currencyData->code,
                'name' => $currencyData->name,
                'active' => true,
                'precision' => $currencyData->decimals,
                // TODO => missing limits/fee
                'info' => $currencyData,
            );
        }
        return $results;
    }

    public function fetch_order_book($symbol, $limit, $params = array ()) {
        $request = array( 'code' => $symbol );
        if ($limit !== null) {
            $request->limit = $limit;
        }
        $orderBook = yield $this->publicGetTradeMarketCodeBook ($request);
        $results = array();
        for ($i = 0; $i < count($orderBook->data); $i++) {
            $orderBookData = $orderBook->data[$i];
            $results[] = array(
                'buy' => $orderBookData->buy,
                'ask' => $orderBookData->sell,
                'timestamp' => $orderBookData->timestamp,
                'nonce' => null,
            );
        }
        return $results;
    }

    public function fetch_ticker($symbol, $params = array ()) {
        yield $this->load_markets();
        return yield $this->fetch_tickers([$symbol], $params);
    }

    public function fetch_tickers($symbols = null, $params = array ()) {
        yield $this->load_markets();
        $data = array();
        for ($i = 0; $i < count($this->markets); $i++) {
            $marketData = $this->markets[$i];
            if ($symbols === null || mb_strpos($symbols, $marketData->id)) {
                $ticker = yield $this->publicGetTradeMarketCodeHistory (array( 'code' => $marketData->id ));
                for ($j = 0; $j < count($ticker->data); $j++) {
                    $data[] = $ticker->data[$j];
                }
            }
        }
        return $data;
    }

    public function fetch_balance() {
        $balances = yield $this->privateGetBalance ();
        $free = array();
        $used = array();
        $total = array();
        for ($i = 0; $i < count($balances->data); $i++) {
            $balanceData = $balances->data[$i];
            $free[$balanceData->available.currency] = $balanceData->available.amount;
            $used[$balanceData->reserved.currency] = $balanceData->reserved.amount;
            $total[$balanceData->total.currency] = $balanceData->total.amount;
        }
        $results = array(
            'info' => $balances->data,
            'free' => $free,
            'used' => $used,
            'total' => $total,
        );
        is_array($total).forEach ((key) ? array_keys($total).forEach ((key) : array() => array(
            $results[key] = array(
                'free' => $free[key],
                'used' => $used[key],
                'total' => $total[key],
            );
        ));
        return $results;
    }

    public function create_order($params = array ()) {
        $request = array(
            'trade-market' => $params->tradeMarket,
            'amount' => $params->amount,
            'side' => $params->side,
            'rate' => $params->rate,
        );
        $response = yield $this->privatePostTradeOrder (array_merge($request, $params));
        return array(
            'info' => $response->data,
            'id' => $response->data.uuid,
        );
    }

    public function cancel_order($params = array ()) {
        $request = array( 'uuid' => $params->uuid );
        return yield $this->privateDeleteTradeOrderUuid ($request);
    }

    public function fetch_order($id, $symbol = null, $params = array ()) {
        $response = yield $this->privateGetTradeOfferUuid (array( 'uuid' => $id ));
        return $this->transform_order_data($response->data);
    }

    public function fetch_orders($symbol = null, $since = null, $limit = null, $params = array ()) {
        $response = yield $this->privateGetTradeOffer ();
        $output = array();
        for ($i = 0; $i < count($response->data); $i++) {
            $orderData = $this->transform_order_data($response->data[$i]);
            $output[] = $orderData;
        }
        return $output;
    }

    public function transform_order_data($responseData) {
        return array(
            'id' => $responseData->uuid,
            'clientOrderId' => $responseData->uuid,
            'datetime' => $responseData->created_at,
            'timestamp' => intval((new Date ($responseData->created_at).getTime () / sprintf('%.0f', 1000))),
            'lastTradeTimestamp' => intval((new Date ($responseData->updated_At).getTime () / sprintf('%.0f', 1000))),
            'status' => $responseData->status,
            'symbol' => $responseData->trade_market,
            'type' => $responseData->type,
            'timeInForce' => $responseData->time_in_force,
            'side' => $responseData->side,
            'amount' => $responseData->amount,
            'filled' => $responseData->amount_filled,
            'cost' => $responseData->amount_cost,
            'info' => $responseData,
        );
    }

    public function sign($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $url = $this->urls['api'] . '/' . $this->version . '/' . $this->implode_params($path, $params);
        $query = $this->omit($params, $this->extract_params($path));
        $headers = $headers || array();
        $headers->Accept = 'application/json';
        if ($api === 'private') {
            $headers->Authorization = 'Bearer ' . $this->apiKey;
        }
        if ($method === 'POST') {
            $body = $this->json($query);
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }
}
